{{BOLD}}ergo quickstart{{RESET}}
{{CYAN}}Complete reference manual. Optimized for agents and humans.{{RESET}}

{{HEADER}}1. INITIALIZE{{RESET}}

{{CMD}}ergo init{{RESET}}
Creates `.ergo/` in the current directory.

{{CMD}}ergo where{{RESET}}
Prints the active `.ergo/` path (useful when running with `--dir`).

{{HEADER}}2. AGENT WORKFLOW{{RESET}}

Your identity is <model>@<hostname> (e.g. sonnet@agent-host).

Core loop:
  1) Claim oldest ready work:
     {{CMD}}ergo --json claim --agent sonnet@agent-host{{RESET}}
     Claim output includes: "When you have completed this claimed task, you MUST mark it done."
  2) Do the work described in the task (write to project files)
  3) Attach results and set state:
     {{CMD}}printf '%s' '{"result_path":"docs/x.md","result_summary":"Spec v1","state":"done"}' | ergo set ABCDEF{{RESET}}
     Never leave tasks in `doing`. Always set done, blocked, error, or canceled.
     Mutating commands return JSON objects when --json is set.
  4) Pull full epic context in one call:
     {{CMD}}ergo --json show EPICID{{RESET}} returns `{"epic": ..., "children": ...}` and each child includes `body`.

Flags:
  - Use `--quiet` to suppress non-essential output (useful for scripts).
  - Use `--verbose` for debug traces on stderr.

Common variants:
  - Claim a specific task by ID:
    {{CMD}}ergo claim ABCDEF --agent sonnet@agent-host{{RESET}}
  - Claim oldest ready task within an epic:
    {{CMD}}ergo claim --agent sonnet@agent-host --epic ABCDEF{{RESET}}
  - If no tasks are ready, claim prints “No ready ergo tasks.” and exits 0.
  - Change state (uses existing claim if present):
    {{CMD}}printf '%s' '{"state":"blocked"}' | ergo set ABCDEF{{RESET}}

{{HEADER}}3. CREATE WORK (JSON stdin){{RESET}}

Use `printf '%s'` for reliable JSON delivery. Heredocs (`<<'JSON'`) can work too, but some terminals/tooling don’t support them reliably. All fields are strings.
Unknown keys are rejected (with suggestions for close matches).

Create a task:
  {{CMD}}printf '%s' '{"title":"Login","body":"Implement signup","epic":"OFKSTE"}' | ergo new task{{RESET}}

Create an epic (prints ID, e.g. OFKSTE):
  {{CMD}}printf '%s' '{"title":"Auth","body":"Signup/Login epic"}' | ergo new epic{{RESET}}

Atomic create-and-claim (preferred for dynamic tasking):
  {{CMD}}printf '%s' '{"title":"Fix CVE","claim":"sonnet@agent-host"}' | ergo new task{{RESET}}
  `claim` implies `state=doing` unless `state` is explicitly set.

{{HEADER}}3b. CREATE WORK (body from stdin){{RESET}}

Use `--body-stdin` when the body is multi-line markdown. In this mode, stdin is the literal body text (non-empty) and metadata is passed via flags.

Create a task with a multi-line body:
  {{CMD}}printf '%s\n' '## Goal' '- Do the thing' '' '## Acceptance criteria' '- Thing is done' | ergo new task --body-stdin --title "Do the thing"{{RESET}}

Update a task body (and state) from stdin:
  {{CMD}}printf '%s\n' '## Status' '- Waiting on review' | ergo set ABCDEF --body-stdin --state blocked{{RESET}}

{{HEADER}}3c. CREATE/UPDATE (flags only){{RESET}}

When stdin is not piped (TTY), you can use flags for simple inputs (short titles/bodies, state changes).

Create a task (no stdin):
  {{CMD}}ergo new task --title "Login" --body "Implement signup" --epic OFKSTE{{RESET}}

Mark done (no stdin):
  {{CMD}}ergo set ABCDEF --state done{{RESET}}

{{HEADER}}4. DEPENDENCIES{{RESET}}

Enforce order (A happens before B):
  {{CMD}}ergo sequence TASK_A TASK_B{{RESET}}

Chain order (A then B then C):
  {{CMD}}ergo sequence TASK_A TASK_B TASK_C{{RESET}}

Remove order between A and B (remove edge where B depends on A):
  {{CMD}}ergo sequence rm TASK_A TASK_B{{RESET}}

Find ready work (all deps done or canceled):
  {{CMD}}ergo list --ready{{RESET}}

{{HEADER}}5. UPDATE & FAILURES{{RESET}}

Mark blocked (waiting on human/external):
  {{CMD}}printf '%s' '{"state":"blocked"}' | ergo set ABCDEF{{RESET}}

Mark error (requires claim to show who failed):
  {{CMD}}printf '%s' '{"state":"error"}' | ergo set ABCDEF{{RESET}}
  If unclaimed, pass --agent or set claim in JSON.

{{HEADER}}6. PRUNE + COMPACT{{RESET}}

`ergo prune` logically deletes completed work. Default is dry-run.

What gets pruned:
  - Tasks in `done` or `canceled`
  - Epics with no remaining children

What is preserved (never pruned):
  - Tasks in `todo`, `blocked`, `doing`, or `error`
  - Epics with active children

Dry-run (preview):
  {{CMD}}ergo prune{{RESET}}

Apply:
  {{CMD}}ergo prune --yes{{RESET}}

`ergo compact` rewrites the log to physically remove pruned history.

{{HEADER}}7. ATTACH RESULTS{{RESET}}

Results are pointers to project files (relative paths).

Attach results (multiple calls accumulate, newest first):
  {{CMD}}printf '%s' '{"result_path":"docs/report.md","result_summary":"Final report"}' | ergo set GHIJKL{{RESET}}

Inspect results:
  {{CMD}}ergo show GHIJKL --json | jq '.results[]'{{RESET}}

{{HEADER}}8. EPIC HIERARCHIES{{RESET}}

Epics complete when all children are done or canceled. They have no own state.
Epic-to-epic deps block all tasks in the dependent epic.

{{CMD}}ergo sequence EPIC_A EPIC_B{{RESET}}

{{HEADER}}REFERENCE: TITLE + BODY{{RESET}}
Use `title` for the task name; `body` for details.
Title is required for new tasks/epics. Legacy tasks without titles are auto-derived on load.

{{HEADER}}REFERENCE: STATE MACHINE{{RESET}}
States: todo, doing, blocked, error, done, canceled

Invariants:
  doing/error require claim; pass --agent or set claim in JSON
  todo/done/canceled clear claim

{{HEADER}}REFERENCE: RULES{{RESET}}

- deps: task-to-task or epic-to-epic only; cycles forbidden
- agent ID format: <model>@<hostname> (recommended, not enforced)
