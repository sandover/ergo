version: '3'

env:
  # Keep Go build artifacts and module downloads inside the repo so local runs
  # don't need the global Go cache dirs (useful in sandboxed environments).
  GOCACHE: '{{.TASKFILE_DIR}}/.gocache/go-build'
  GOMODCACHE: '{{.TASKFILE_DIR}}/.gocache/go-mod'

vars:
  VERSION:
    sh: git describe --tags --always --dirty
  GOLANGCI_LINT_VERSION: v1.64.8

tasks:
  default:
    desc: Install this repo's ergo build into your Go bin (alias for `task install`)
    silent: true
    cmds:
      - task: install

  install:
    desc: Compile with version metadata and install `ergo` to GOBIN (or GOPATH/bin)
    silent: true
    cmds:
      - printf '%s\n' "[install] go install ./cmd/ergo"
      - go install -ldflags "-X main.version={{.VERSION}}" ./cmd/ergo
      - |
        set -euo pipefail
        bin="$(go env GOBIN)"
        if [[ -z "${bin}" ]]; then
          gopath="$(go env GOPATH | cut -d: -f1)"
          bin="${gopath}/bin"
        fi
        printf '%s\n' "Installed ergo {{.VERSION}} to ${bin}/ergo"

  build:
    desc: Build a local versioned binary at ./bin/ergo (no global install)
    silent: true
    cmds:
      - printf '%s\n' "[build] bin/ergo"
      - mkdir -p bin
      - go build -ldflags "-X main.version={{.VERSION}}" -o bin/ergo ./cmd/ergo
      - printf '%s\n' "Built bin/ergo {{.VERSION}}"

  run:
    desc: Run ergo from source via `go run` (pass args like `task run -- list`)
    silent: true
    cmds:
      - |
        set -euo pipefail
        args="{{.CLI_ARGS}}"
        if [[ -n "${args}" ]]; then
          printf '%s\n' "[run] ergo ${args}"
        else
          printf '%s\n' "[run] ergo (no args)"
        fi
        go run ./cmd/ergo {{.CLI_ARGS}}

  test:
    desc: Run full test suite with the race detector (matches correctness gate)
    silent: true
    cmds:
      - printf '%s\n' "[test] go test -race ./..."
      - go test -race ./...

  cover:
    desc: Run race-enabled tests and print total code coverage
    silent: true
    cmds:
      - printf '%s\n' "[cover] go test -race -coverprofile=coverage.out ./..."
      - go test -race -coverprofile=coverage.out ./...
      - printf '%s\n' "[cover] go tool cover -func=coverage.out (total)"
      - go tool cover -func=coverage.out | tail -n 1

  bench:
    desc: Run all benchmarks with allocation stats (`-benchmem`)
    silent: true
    cmds:
      - printf '%s\n' "[bench] go test -bench=. -benchmem ./..."
      - go test -bench=. -benchmem ./...

  fmt:
    desc: Gofmt all Go package directories in this repo
    silent: true
    cmds:
      - printf '%s\n' "[fmt] gofmt -w (go list ./...)"
      - |
        set -euo pipefail
        # Avoid formatting third-party sources now that we use a repo-local GOMODCACHE.
        gofmt -w $(go list -f '{{"{{"}}.Dir{{"}}"}}' ./... | sort -u)

  vet:
    desc: Go vet static analysis for suspicious constructs across all packages
    silent: true
    cmds:
      - printf '%s\n' "[vet] go vet ./..."
      - go vet ./...

  lint:
    desc: Run pinned golangci-lint ruleset (same linter version as CI)
    silent: true
    cmds:
      - GOLANGCI_LINT_VERSION={{.GOLANGCI_LINT_VERSION}} ./scripts/golangci-lint.sh run ./...

  ci:
    desc: Execute CI parity script (tidy, lint, and tests)
    silent: true
    cmds:
      - GOLANGCI_LINT_VERSION={{.GOLANGCI_LINT_VERSION}} ./scripts/ci.sh

  clean:
    desc: Remove local build outputs and coverage artifacts
    silent: true
    cmds:
      - printf '%s\n' "[clean] rm -rf bin/ dist/ coverage.out"
      - rm -rf bin/ dist/ coverage.out
